---
layout: post

title: Swift 3.0 笔记

date: 2017-03-2 15:32:24.000000000 +09:00

---


[看看1](http://www.uml.org.cn/mobiledev/201702151.asp)

## Public 和 Open 都用来声明函数或者类的作用域
Public 可以被其他模块访问， Open 权限大于Public  不仅可以访问还可以继承。

+ fileprivate 文件内可见 
+ final 任何地方都不能继承。

[参考](http://www.jianshu.com/p/604305a61e57)

## static 和 class 
都可用来修饰 类方法 但是static修饰的类方法不能被继承 用class 修饰的类方法是可以被继承的

+ class func  classMethod() {} //可以被继承
+ static func  staticMethod() {} // 不可以被继承 有包含final关键字的特性 Error：Class method overrides a 'final' class method.
+ 在protocol里要用class来统一修饰 class ，struct 和enum在 *类型域* 上的方法，但在struct和enum具体实现时还是用static来修饰

[参考](http://www.jianshu.com/p/a9c9e7313438)

[参考](http://swifter.tips/static-class/)

## @escaping 和 @noescaping

+ @escaping 逃逸闭包 ：当闭包作为函数参数时，在函数执行完后才被调用，调用的地方超过了这个函数的范围就是逃逸闭包 eg：网络请求的completionHandler ,
+ @noescaping 非逃逸闭包：才函数结束前就被调用。线性布局约束的闭包Cartography
+ Swift 3.0 中默认都是@noescaping非逃逸闭包，如果要用到逃逸闭包必须要在 *闭包参数前声明* @escaping
+ 应该是跟block的内存管理优化有关


## forEach 和 for in




## protocol的优势
1. 更优雅的给struct class 添加方法 ，只要你满足我的协议我会给你更多的能力。
2. 在搭建模型结构系统时，抽象出层层的逻辑协议protocol，可以大量复用protocol的扩展接口，更清晰的搭建模型结构系统。



## swift extension 中添加变量

```
public extension UIScrollView {

    // MARK: -
    // MARK: Vars

    private struct dg_associatedKeys {
        static var pullToRefreshView = "pullToRefreshView"
    }

    private var _pullToRefreshView: DGElasticPullToRefreshView? {
        get {
            if let pullToRefreshView = objc_getAssociatedObject(self, &dg_associatedKeys.pullToRefreshView) as? DGElasticPullToRefreshView {
                return pullToRefreshView
            }

            return nil
        }
        set {
            objc_setAssociatedObject(self, &dg_associatedKeys.pullToRefreshView, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
    }

    private var pullToRefreshView: DGElasticPullToRefreshView! {
        get {
            if let pullToRefreshView = _pullToRefreshView {
                return pullToRefreshView
            } else {
                let pullToRefreshView = DGElasticPullToRefreshView()
                _pullToRefreshView = pullToRefreshView
                return pullToRefreshView
            }
        }
    }
```
## Swift中闭包的__Weak和__Block 的用法

Swift 中闭包避免引用循环的办法：

### 第一种：

```
  let shop : LRShop = LRShop()
    weak var weakShop = shop
    shop.myBlock = {(str : String) -> () in
        weakShop?.string = str
        print((weakShop?.string)!)
    }
    shop.myBlock!(str: "哈喽，你好！")
```

### 第二种：

```
    let shop : LRShop = LRShop()   
    shop.myBlock = {[unowned shop] (str : String) -> () in
        shop.string = str
        print(shop.string!)
    }
    shop.myBlock!(str: "哈喽，你好！")
```

### 第三种

```
    let shop : LRShop = LRShop()
    shop.myBlock = {[weak shop] (str : String) -> () in
            shop?.string = str
            print((shop?.string)!)
    }
    shop.myBlock!(str: "哈喽，你好！")
```

### 第四种

```
    let shop : LRShop = LRShop()

    shop.myBlock = {[weak shop] (str : String) -> () in
          //强引用
        let strongShop = shop;

        //时间设置
        let time: NSTimeInterval = 2
        //GCD：延迟2秒
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW,
            Int64(time * Double(NSEC_PER_SEC))), dispatch_get_main_queue()) {
                //赋值
                strongShop?.string = str
                //打印输出
                print((strongShop?.string)!)
        }
    }
    shop.myBlock!(str: "哈喽，你好！")
```

Swift里面Block都是默认截获引用，也就是默认都加了__block.

```
var x = 42
let f = {
    // [x] in //如果取消注释，结果是42
    print(x)
}
x = 43

f() // 结果是43
```

但是如果写在参数列表里面，那么就会像函数的参数一样，重新生成一个拷贝。这点与OC完全相反

关于Swift的循环引用，有一个需要注意的例子：

```
class A {
    var name: String = "A"
    var block: (() -> ())?

    //其他方法
}

var a: A? = A()
var block = {
    print(a?.name)
}
a?.block = block
a = nil
block()
```

我们先创建了可选类型的变量a，然后创建一个闭包变量，并把它赋值给a的block属性。这个闭包内部又会截获a，那这样是否会导致循环引用呢？

答案是否定的。虽然从表面上看，对象的闭包属性截获了对象本身。但是如果你运行上面这段代码，你会发现对象的deinit方法确实被调用了，打印结果不是“A”而是“nil”。

这是因为我们忽略了可选类型这个因素。这里的a不是A类型的对象，而是一个可选类型变量，其内部封装了A的实例对象。闭包截获的是可选类型变量a，当你执行a = nil时，并不是释放了变量a，而是释放了a中包含的A类型实例对象。所以A的deinit方法会执行，当你调用block时，由于使用了可选链，就会得到nil，如果使用强制解封，程序就会崩溃。

如果想要人为造成循环引用，代码要这样写：

```
var block: (() -> ())?
if true {
    var a = A()
    block = {
        print(a.name)
    }
    a.name = "New Name"
}
block!()
```

### 总结
- OC中默认截获变量，Swift默认截获变量的引用。它们都会强引用被截获的变量。
- Swift中没有__block修饰符，但是多了截获列表。通过把截获的变量标记为weak避免引用循环
- 两者都有Weak-Strong Dance，不过这一点上OC的写法更简单。
- 在使用可选类型时，要明确闭包截获了可选类型还是实例变量。这样才能正确判断是否发生循环引用。