---
layout: post

title: Swift 3.0 笔记

date: 2017-03-2 15:32:24.000000000 +09:00

---


[看看1](http://www.uml.org.cn/mobiledev/201702151.asp)

## Public 和 Open 都用来声明函数或者类的作用域
Public 可以被其他模块访问， Open 权限大于Public  不仅可以访问还可以继承。

+ fileprivate 文件内可见 
+ final 任何地方都不能继承。

[参考](http://www.jianshu.com/p/604305a61e57)

## static 和 class 
static 和 class 在类中的应用，都可用来修饰 类方法 但是static修饰的类方法不能被继承 用class 修饰的类方法是可以被继承的

+ class func  classMethod() {} //可以被继承
+ static func  staticMethod() {} // 不可以被继承 有包含final关键字的特性 Error：Class method overrides a 'final' class method.
+ 在protocol里要用class来统一修饰 class ，struct 和enum在 `类型域` 上的方法，但在struct和enum具体实现时还是用static来修饰

```
class Star {
  class func spin() {}
  static func illuminate() {}
}
  
class Sun : Star {
  override class func spin() {
    super.spin()
  }
  override static func illuminate() { // error: class method overrides a 'final' class method
    super.illuminate()
  }
}
```

[参考](http://www.jianshu.com/p/a9c9e7313438)

[参考](http://swifter.tips/static-class/)

## @escaping 和 @noescaping

+ @escaping 逃逸闭包 ：当闭包作为函数参数时，在函数执行完后才被调用，调用的地方超过了这个函数的范围就是逃逸闭包 

```
func doWorkAsync(block: @escaping ()->()) {	DispatchQueue.main.async {		block()	}}
```
+ @noescaping 非逃逸闭包：才函数结束前就被调用。线性布局约束的闭包Cartography

```
func doWork(block: ()->()) {	block()}doWork {	print("work")}
```

+ Swift 3.0 中默认都是@noescaping非逃逸闭包，如果要用到逃逸闭包必须要在 `闭包参数前声明` @escaping
+ 对于 @escaping 类型的闭包 如果引用了self，编译是要强制写出来self的。已提醒程序员这里引用了self。

```
class S {	var foo = "foo"	func method1() {			doWork { 			//非逃逸闭包 作用域仅限于method1函数内，不担心强引用self				print(foo)			}			foo = "bar"	}	func method2() {			doWorkAsync {		//逃逸闭包 强引用self，如果用 [weak self] 则有可能闭包被调用时 self被释放				print(self.foo)			}			foo = "bar"	}}S().method1() // fooS().method2() // bar
```


## forEach 和 for in




## protocol的优势
1. 更优雅的给struct class 添加方法 ，只要你满足我的协议我会给你更多的能力。
2. 在搭建模型结构系统时，抽象出层层的逻辑协议protocol，可以大量复用protocol的扩展接口，更清晰的搭建模型结构系统。



## swift extension 中添加变量

```
public extension UIScrollView {

    // MARK: -
    // MARK: Vars

    private struct dg_associatedKeys {
        static var pullToRefreshView = "pullToRefreshView"
    }

    private var _pullToRefreshView: DGElasticPullToRefreshView? {
        get {
            if let pullToRefreshView = objc_getAssociatedObject(self, &dg_associatedKeys.pullToRefreshView) as? DGElasticPullToRefreshView {
                return pullToRefreshView
            }

            return nil
        }
        set {
            objc_setAssociatedObject(self, &dg_associatedKeys.pullToRefreshView, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
    }
```
## Swift中闭包的__Weak和__Block 的用法

Swift 中闭包避免引用循环的办法：

### 第一种：

```
  let shop : LRShop = LRShop()
    weak var weakShop = shop
    shop.myBlock = {(str : String) -> () in
        weakShop?.string = str
        print((weakShop?.string)!)
    }
    shop.myBlock!(str: "哈喽，你好！")
```

### 第二种：

```
    let shop : LRShop = LRShop()   
    shop.myBlock = {[unowned shop] (str : String) -> () in
        shop.string = str
        print(shop.string!)
    }
    shop.myBlock!(str: "哈喽，你好！")
```

### 第三种

```
    let shop : LRShop = LRShop()
    shop.myBlock = {[weak shop] (str : String) -> () in
            shop?.string = str
            print((shop?.string)!)
    }
    shop.myBlock!(str: "哈喽，你好！")
```

### 第四种

```
    let shop : LRShop = LRShop()

    shop.myBlock = {[weak shop] (str : String) -> () in
          //强引用
        let strongShop = shop;

        //时间设置
        let time: NSTimeInterval = 2
        //GCD：延迟2秒
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW,
            Int64(time ` Double(NSEC_PER_SEC))), dispatch_get_main_queue()) {
                //赋值
                strongShop?.string = str
                //打印输出
                print((strongShop?.string)!)
        }
    }
    shop.myBlock!(str: "哈喽，你好！")
```

Swift里面Block都是默认截获引用，也就是默认都加了__block.

```
var x = 42
let f = {
    // [x] in //如果取消注释，结果是42
    print(x)
}
x = 43

f() // 结果是43
```

但是如果写在参数列表里面，那么就会像函数的参数一样，重新生成一个拷贝。这点与OC完全相反

关于Swift的循环引用，有一个需要注意的例子：

```
class A {
    var name: String = "A"
    var block: (() -> ())?

    //其他方法
}

var a: A? = A()
var block = {
    print(a?.name)
}
a?.block = block
a = nil
block()
```

我们先创建了可选类型的变量a，然后创建一个闭包变量，并把它赋值给a的block属性。这个闭包内部又会截获a，那这样是否会导致循环引用呢？

答案是否定的。虽然从表面上看，对象的闭包属性截获了对象本身。但是如果你运行上面这段代码，你会发现对象的deinit方法确实被调用了，打印结果不是“A”而是“nil”。

这是因为我们忽略了可选类型这个因素。这里的a不是A类型的对象，而是一个可选类型变量，其内部封装了A的实例对象。闭包截获的是可选类型变量a，当你执行a = nil时，并不是释放了变量a，而是释放了a中包含的A类型实例对象。所以A的deinit方法会执行，当你调用block时，由于使用了可选链，就会得到nil，如果使用强制解封，程序就会崩溃。

如果想要人为造成循环引用，代码要这样写：

```
var block: (() -> ())?
if true {
    var a = A()
    block = {
        print(a.name)
    }
    a.name = "New Name"
}
block!()
```
## map 和 flatmap
### Sequence的map 

```
简单映射
let arr = [1, 2, 4] 
let brr = arr.map { "No." + String($0) } // brr = ["No.1", "No.2", "No.4"] 
```
### Sequence的flatmap 

```
降维展开
let arr = [[1, 2, 3], [6, 5, 4]]
let brr = arr.flatMap { $0 } // brr = [1, 2, 3, 6, 5, 4]

过滤 经过转换后为nil 的结果
let arr: [Int?] = [1, 2, nil, 4, nil, 5] 
let brr = arr.flatMap { $0 } // brr = [1, 2, 4, 5]
let images = (1...6).flatMap {
    UIImage(named: "imageName-\($0)") 
}  
```
### Optional的map
 
```
不解包的情况下可以直接运算
let b2 = a2.map { (a : Int) -> Int in
    return a ` 2
}
之前：
var date: NSDate? = ...
var formatted = date == nil ? nil : NSDateFormatter().stringFromDate(date!)
之后：
var date: NSDate? = ...
var formatted = date.map(NSDateFormatter().stringFromDate)

```
### Optional的flatMap

```
不解包的情况下可以直接运算 + 自动过滤 转换后为nil的结果
let s: String? = "abc"
let v = s.flatMap { (a: String) -> Int? in
    return Int(a)
}

```
## Swift 的错误处理
### 同步API 用 throw 强制使用 do try catch 
```
do {	try d.write(toFile: "Hello", options: [])} catch let error as NSError {	print ("Error: \(error.domain)")}
```
### 异步API 使⽤泛型枚举。

```
enum Result<T> {	case Success(T)	case Failure(NSError)}

func doSomethingParam(param:AnyObject) -> Result {//...做某些操作，成功结果放在 success 中	if success {		return Result.Success("成功完成")	} else {		let error = NSError(domain: "errorDomain", code: 1, userInfo: nil)		return Result.Error(error)	}}
```
## let 和 var
### 当let修饰class时, 引用不能被重新赋值，但引用的对象属性可以

```
let view2 = UIView()
view2.alpha = 0.5 // compile ok
view2 = UIView()  // compile error

```
### 当let修饰struct时，调用struct的mutating方法是不被允许的

```
public struct ThermometerStruct {
  private(set) var temperature: Double = 0.0
  public mutating func registerTemperature(temperature: Double) {
    self.temperature = temperature
  }
}
 
let thermometerStruct = ThermometerStruct()
thermometerStruct.registerTemperature(56.0) // compiler error
```

## closure的抓捕列表
OC语言中 用__bock来表示的 closure 是 引用还是拷贝 作用域里的值。
Swift里 用捕获列表表示，在捕获列表里的用copy，不在的用引用。 
```
var thing = "cars"
let closure = { [thing] in
  print("I love \(thing)")
}
thing = "airplanes"
closure()  // print I love cars
```
当捕获表里声明了要捕获thing时，thing就被拷贝了一份在closure里

```
var thing = "cars"
let closure = {   
  print("I love \(thing)")
}
thing = "airplanes"
closure() // Prints "I love airplanes"
```
当捕获表里不声明任何变量时，closure里只会简单的引用作用域里的变量，不做拷贝。

## 字面量

```
let a = Array<Int>([1,2,3])//Array 的初始化方法
let b = [1,2,3] //Array 支持实现了字面量协议:ExpressibleByArrayLiteral

let a = String("hello") //String 的初始化方法
let b = "hello" //String 支持实现了字面量协议:ExpressibleByStringLiteral
```
下面自己定一个类来支持 `ExpressibleByStringLiteral` 字符串的字面量协议。支持私服穿的字面量协议要同时支持另外两个个协议。`ExpressibleByExtendedGraphemeClusterLiteral` 和 `ExpressibleByUnicodeScalarLiteral`

```
public protocol ExpressibleByStringLiteral : ExpressibleByExtendedGraphemeClusterLiteral {
    associatedtype StringLiteralType
    public init(stringLiteral value: Self.StringLiteralType)
}

public protocol ExpressibleByExtendedGraphemeClusterLiteral : ExpressibleByUnicodeScalarLiteral {
    associatedtype ExtendedGraphemeClusterLiteralType
    public init(extendedGraphemeClusterLiteral value: Self.ExtendedGraphemeClusterLiteralType)
}

public protocol ExpressibleByUnicodeScalarLiteral {
    associatedtype UnicodeScalarLiteralType
    public init(unicodeScalarLiteral value: Self.UnicodeScalarLiteralType)
}

```
定义一个Person类

```
class Person {	let name: String	init(name value: String) {		self.name = value	}}

class Person: ExpressibleByStringLiteral {	let name: String	init(name value: String) {		self.name = value	}	required convenience init(stringLiteral value: String) {		self.init(name: value)	}	required convenience init(extendedGraphemeClusterLiteral value: 	String) {		self.init(name: value)	}	required convenience init(unicodeScalarLiteral value: String) {		self.init(name: value)	}}let p: Person = "xiaoMing"print(p.name)// 输出：// xiaoMing
```
这个Person类就可以支持 字面量的直接创建了。语义更清晰。代码更简单。

## 重载操作符

```
precedencegroup PowPrecedence {
    associativity: right   //结合律 eg：prefix | postfix
    higherThan: MultiplicationPrecedence //优先级 eg：AdditionPrecedence
}

infix operator ^^: PowPrecedence 

func ^^(lhs: Int, rhs: Int) -> Int {
    let l = Double(lhs)
    let r = Double(rhs)
    let p = pow(l, r)
    return Int(p)
}
print( 2^^3) //2 的 3次方 等于 8 
```
## 递归枚举 关键字 indirect

```
indirect enum List<T>{
     case Node(T, List)
}
```

## 枚举类型

+ [参考](http://swift.gg/2015/11/20/advanced-practical-enum-examples/)

## Swift语言动态性 运行时相关

### @objc 和 dynamic 
这两个关键字都用来修饰 Swift 的 类和方法，需要像OC一样有动态化的能力，即享受了函数表派发的高性能，又了语言的动态性。

+ 纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。
+ 值得注意的是 ：加了@objc标识的方法、属性无法保证都会被运行时调用，因为Swift会做静态优化。要想完全被动态调用，必须使用dynamic修饰。使用dynamic修饰将会隐式的加上@objc标识。

+ 继承自NSObject的Swift类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加dynamic修饰才可以获得动态性。

```
class MyViewController: UIViewController{
	overide func viewDidLoad(){   //前面就有 @objc
	}
	func setupSubviews(){ //自己后来添加的就没有 @objc 
	}
	func loadUrl(){ //自己后来添加的就没有 @objc 
	}
}
```
+ Swift类在Objective-C中会有模块前缀 `id cls = objc_getClass("YourTarget.MyViewController");` 

+ 若方法的参数、属性类型为Swift特有、无法映射到Objective-C的类型(如Character、Tuple)，则此方法、属性无法添加dynamic修饰（会编译错误）

+ [Swift Runtime动态性分析](http://www.infoq.com/cn/articles/dynamic-analysis-of-runtime-swift)

### Swift函数派发机制

编译型语言三种基础的函数派发方式：

+ `直接派发(Direct Dispatch)` 性能最高的方式，直接绑定函数地址，又叫静态编译
+ `函数表派发(Table Dispatch)` 最常见的方式，类模型里维护一个虚函数表，子类增加新的方法就添加在子类虚函数表的后面，覆盖父类的方法就直接替换函数地址。运行时通过虚函数表决定实际调用的函数。
+ `消息机制派发(Message Dispatch)` 最动态的方式,功能强大，swizzling，甚至改变继承关系，自定义派发，`Objective-C` 会用树来构建这种继承关系，当一个消息被派发, 运行时会顺着类的继承关系向上查找应该被调用的函数. 但效率很低。

>Java 默认使用函数表派发, 但你可以通过 final 修饰符修改成直接派发. C++ 默认使用直接派发, 但可以通过加上 virtual 修饰符来改成函数表派发. 而 Objective-C 则总是使用消息机制派发, 但允许开发者使用 C 直接派发来获取性能的提高. 

而Swift的派发机制目前跟下面四个因素有关：

+ 声明的位置
+ 引用类型
+ 特定的行为
+ 显式地优化(Visibility Optimizations)

+ [深入理解 Swift 派发机制](https://kemchenj.github.io/2017/01/09/2016-12-25-1/)


+ 方法的来源：
	+ 没有载体 ：全局函数  `静态编译`
	+ 有类和结构体作载体
		+ 在类或者结构体里声明
		+ 在extension里声明 `静态编译`

+ ios方法来源
	+ Objetive-C 
		+ Class/SubClass 
		+ Category : @interface UIImage (GIF) 将类的功能分开写，运行时加载
		+ Extension : @interface Person (）不指定名字,用于指定私有方法 编译期确定
	+ Swift
		+ Class/SubClass
		+ Extension
		+ ProtocolExtension 
		
		 
+ Objetive-C Category原理
+ ProtocolExtension 原理
+ [深入理解Objective-C：Category](http://tech.meituan.com/DiveIntoCategory.html)

## Swift的优势

+ 性能
	+ 比OC运行快1.3倍，密集运算时 仅次于C++。
	+ `静态类型` 编译期确定类型，用vtable直接绑定函数地址，不需要动态查找方法，即时报错。
	+ `编译器优化` 更智能检测代码逻辑，eg:为循环体内的对象生成才有合适策略。
+ 安全
	+ `可选值` 区分了nil和非nil
	+ `throw` 错误处理 强制使用 do try catch、
	+ `let var` 变量区分 可变与不可变
+ 效率
	+ `范型` 节省大量因类型不同而导致重复功能的代码
	+ `语法简洁` 函数式语法的支持，重载操作符，字面量
	+ `struct` 和 `enum` 支持方法 并且还是安全值类型
	+ `protocol extension` 更强大的代码复用机制


## 总结
- OC中默认截获变量，Swift默认截获变量的引用。它们都会强引用被截获的变量。
- Swift中没有__block修饰符，但是多了截获列表。通过把截获的变量标记为weak避免引用循环
- 两者都有Weak-Strong Dance，不过这一点上OC的写法更简单。
- 在使用可选类型时，要明确闭包截获了可选类型还是实例变量。这样才能正确判断是否发生循环引用。